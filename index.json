[{"content":"在线编辑\nWaline 评论后台管理\nHugo 文档\nHugo GitHub 仓库\nPaperMod 主题文档\n","permalink":"https://kiyanyang.github.io/extras/management/","summary":"我的网站管理。","title":"网站管理"},{"content":"HashTool 哈希校验工具 项目地址：GitHub\n可以计算文件，文件夹或文本的哈希值。 支持 MD5, SHA1, SHA2, SHA3 等多种哈希算法，详见 wiki。 支持拖放文件和文件夹。 现代化且友好的界面。 支持简体中文和英语。 ","permalink":"https://kiyanyang.github.io/extras/open-source-software/","summary":"我的开源软件。","title":"我的开源软件"},{"content":"注意：下方为简略版，完整版请前往 s.dotvast.cc。\n工具模式： 生成全新短链接 更新已有短链接 长链接 短链接 密钥 生成 更新 状态 链接 复制 密钥 复制 使用说明 短链接工具包含“生成全新短链接”，“更新已有短链接”两个模式。\n备注：\n本工具不保证可用性。 由于远端及本地缓存设置，部分操作将在最多 10 分钟后生效。 生成模式 输入 15 ≤ 长度 ≤ 500 的长链接，点击“生成”按钮，获取短链接和相应密钥。密钥用于“更新”等功能，如不需要这些功能，可以忽略该密钥。\n相关规范如下：\n项目 必选 规范 基本正则校验 长链接 是 规范链接；15 ≤ 长度 ≤ 500 ^.{15,500}$ 密钥 否 无空白字符；4 ≤ 长度 ≤ 24 ^[^\\s\\uFEFF\\xA0]{4,24}$ 备注：\n上述校验规则为基本验证，可能会在后端进行更严格的校验。 无密钥值或该值无效，则由系统生成 8 位长的随机密钥。 密钥明文储存，请不要使用日常所用密码作为密钥。 更新模式 输入 15 ≤ 长度 ≤ 500 的长链接、已有短链接和相应密钥，点击“更新”按钮，即可更新短链接对应的长链接。\n相关规范如下：\n项目 必选 规范 基本正则校验 长链接 是 规范链接；15 ≤ 长度 ≤ 500 ^.{15,500}$ 短链接 是 有效短链接 密钥 是 短链接对应的密钥 ^[^\\s\\ufeff\\xa0]{4,24}$ 备注：\n上述校验规则为基本验证，可能会在后端进行更严格的校验。 短链接可以写短码，例如 https://s.dotvast.cc/1111dv 可以只写 1111dv。 ","permalink":"https://kiyanyang.github.io/extras/short-url/","summary":"短链接工具。","title":"短链接工具"},{"content":" 来自 GitHub 上的开源网页游戏项目\n点击游戏名称进入游戏，如果有其他好玩的网页游戏，也欢迎在下面评论：\n游戏 项目链接 俄罗斯方块 chvin/react-tetris 吃豆人 mumuy/pacman 坦克大战 shinima/battle-city 国际象棋 ornicar/lila 2048 austinzheng/swift-2048 星际大战 gd4Ark/star-battle 滑动拼图 gamedolphin/sliding_puzzle ","permalink":"https://kiyanyang.github.io/extras/open-source-games/","summary":"开源的网页小游戏。","title":"网页小游戏"},{"content":"从微软开发文档「在 Win32 应用中支持深色和浅色主题」中可知，WinUI 3 支持深色和浅色主题，但是其标题栏是个例外，还好我们往往会通过自定义标题栏来完成深色模式的支持。然而，不幸地是我们往往不会去自定义标题栏菜单，导致菜单无法跟随系统或软件的主题设置。\n本文使用 Windows 的非公开 API 来支持标题栏原生菜单的深色主题。\n相关 API 暗色模式 API 参考 ysc3839/win32-darkmode：\nC\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 // 1903 18362 enum PreferredAppMode { Default, AllowDark, ForceDark, ForceLight, Max }; using fnSetPreferredAppMode = PreferredAppMode (WINAPI *)(PreferredAppMode appMode); // ordinal 135, in 1903 using fnFlushMenuThemes = void (WINAPI *)(); // ordinal 136 对于 PreferredAppMode 我们关注 AllowDark、ForceDark、ForceLight 三个值。AllowDark 是跟随系统主题，而后两个是手动控制的主题。\n实现 创建调用代码：\nC# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private enum PreferredAppMode { Default, AllowDark, ForceDark, ForceLight, Max }; [DllImport(\u0026#34;uxtheme.dll\u0026#34;, EntryPoint = \u0026#34;#135\u0026#34;)] private static extern IntPtr SetPreferredAppMode(PreferredAppMode preferredAppMode); [DllImport(\u0026#34;uxtheme.dll\u0026#34;, EntryPoint = \u0026#34;#136\u0026#34;)] private static extern IntPtr FlushMenuThemes(); 创建辅助方法：\nC# 1 2 3 4 5 6 7 8 9 10 11 public static void UpdateTitleBarContextMenu(Microsoft.UI.Xaml.ElementTheme theme) { var mode = theme switch { ElementTheme.Light =\u0026gt; PreferredAppMode.ForceLight, ElementTheme.Dark =\u0026gt; PreferredAppMode.ForceDark, _ =\u0026gt; PreferredAppMode.AllowDark, }; SetPreferredAppMode(mode); FlushMenuThemes(); } 这样我们就可以通过传入元素主题来刷新菜单主题。\n效果如下：\n","permalink":"https://kiyanyang.github.io/posts/43fb94d0/","summary":"WinUI 3 自动支持深色和浅色主题，但是其原生标题栏却没有自动支持，本文通过调用非公开的 Windows API 为 WinUI 3 标题栏原生菜单添加深色主题支持。","title":"为 WinUI 3 标题栏原生菜单添加深色主题支持"},{"content":"通用 恢复 Microsoft Store Win+R 打开「运行」，输入 wsreset.exe，确定。\n参考：\nMicrosoft Store doesn\u0026rsquo;t open ","permalink":"https://kiyanyang.github.io/posts/669e05b6/","summary":"Windows 使用技巧。","title":"Windows 使用技巧"},{"content":"通过对 .Net6 和 .Net7 反射性能的简要测试，为性能优化提供依据。本文测试了以下项目：\n名称 内容 ReadPub 读取公开属性 ReadPriByReflection 通过反射读取私有属性 ReadPriByCachedReflection 通过缓存的反射读取私有属性 ReadPriByDelegate 通过委托读取私有属性 ReadPriByCachedDelegate 通过缓存的委托读取私有属性 ReadPriByExpression 通过表达式树读取私有属性 ReadPriByCachedExpression 通过缓存的表达式树读取私有属性 源代码：DotVast.Benchmark.Reflection/ReadProperty\n测试代码片段 C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 using System.Linq.Expressions; using System.Reflection; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace DotVast.Benchmark.Reflection; internal class Program { static void Main(string[] args) { BenchmarkRunner.Run\u0026lt;ReadProperty\u0026gt;(); } } [SimpleJob(runtimeMoniker: RuntimeMoniker.Net60)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net70, baseline: true)] [MemoryDiagnoser] public class ReadProperty { private readonly User _user = new(); [Benchmark] public string ReadPub() { return _user.Pub; } /////////////////////////////////////////////////////////////////////////////////// /// Reflection [Benchmark] public string ReadPriByReflection() { var propertyInfo = typeof(User).GetProperty(\u0026#34;Pri\u0026#34;, BindingFlags.Instance | BindingFlags.NonPublic)!; return (string)propertyInfo.GetValue(_user)!; } static readonly PropertyInfo _propInfo = typeof(User).GetProperty(\u0026#34;Pri\u0026#34;, BindingFlags.Instance | BindingFlags.NonPublic)!; [Benchmark] public string ReadPriByCachedReflection() { return (string)_propInfo.GetValue(_user)!; } /////////////////////////////////////////////////////////////////////////////////// /// Delegate [Benchmark] public string ReadPriByDelegate() { var propertyInfo = typeof(User).GetProperty(\u0026#34;Pri\u0026#34;, BindingFlags.Instance | BindingFlags.NonPublic)!; var delFunc = (Func\u0026lt;User, string\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;User, string\u0026gt;), propertyInfo.GetMethod!); return delFunc(_user); } static readonly Func\u0026lt;User, string\u0026gt; _delFunc = (Func\u0026lt;User, string\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;User, string\u0026gt;), _propInfo.GetMethod!); [Benchmark] public string ReadPriByCachedDelegate() { return _delFunc(_user); } /////////////////////////////////////////////////////////////////////////////////// /// Expression [Benchmark] public string ReadPriByExpression() { var propertyInfo = typeof(User).GetProperty(\u0026#34;Pri\u0026#34;, BindingFlags.Instance | BindingFlags.NonPublic)!; var parameter = Expression.Parameter(typeof(User)); var propertyExpression = Expression.Property(parameter, propertyInfo); var expFunc = Expression.Lambda\u0026lt;Func\u0026lt;User, string\u0026gt;\u0026gt;(propertyExpression, parameter).Compile(); return expFunc(_user); } static readonly ParameterExpression _parameter = Expression.Parameter(typeof(User)); static readonly MemberExpression _propExpression = Expression.Property(_parameter, _propInfo); static readonly Func\u0026lt;User, string\u0026gt; _expFunc = Expression.Lambda\u0026lt;Func\u0026lt;User, string\u0026gt;\u0026gt;(_propExpression, _parameter).Compile(); [Benchmark] public string ReadPriByCachedExpression() { return _expFunc(_user); } } public sealed class User { public string Pub =\u0026gt; \u0026#34;Public\u0026#34;; private string Pri =\u0026gt; \u0026#34;Private\u0026#34;; } 结果 BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i5-8250U CPU 1.60GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 .NET 6.0 : .NET 6.0.11 (6.0.1122.52304), X64 RyuJIT AVX2 .NET 7.0 : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Job | Runtime | Mean | Error | StdDev | Ratio | Gen0 | Gen1 | Allocated | Alloc Ratio | |-------------------------- |--------- |--------- |---------------:|------------:|------------:|------:|-------:|-------:|----------:|------------:| | ReadPub | .NET 6.0 | .NET 6.0 | 0.4791 ns | 0.0086 ns | 0.0080 ns | 0.34 | - | - | - | NA | | ReadPub | .NET 7.0 | .NET 7.0 | 1.3930 ns | 0.0069 ns | 0.0061 ns | 1.00 | - | - | - | NA | | | | | | | | | | | | | | ReadPriByReflection | .NET 6.0 | .NET 6.0 | 94.9653 ns | 0.4266 ns | 0.3782 ns | 2.13 | - | - | - | NA | | ReadPriByReflection | .NET 7.0 | .NET 7.0 | 44.5251 ns | 0.0936 ns | 0.0876 ns | 1.00 | - | - | - | NA | | | | | | | | | | | | | | ReadPriByCachedReflection | .NET 6.0 | .NET 6.0 | 61.6544 ns | 0.1326 ns | 0.1240 ns | 4.21 | - | - | - | NA | | ReadPriByCachedReflection | .NET 7.0 | .NET 7.0 | 14.6585 ns | 0.0218 ns | 0.0204 ns | 1.00 | - | - | - | NA | | | | | | | | | | | | | | ReadPriByDelegate | .NET 6.0 | .NET 6.0 | 452.9171 ns | 2.9943 ns | 2.8008 ns | 1.07 | 0.0200 | - | 64 B | 1.00 | | ReadPriByDelegate | .NET 7.0 | .NET 7.0 | 422.1861 ns | 0.7520 ns | 0.6666 ns | 1.00 | 0.0200 | - | 64 B | 1.00 | | | | | | | | | | | | | | ReadPriByCachedDelegate | .NET 6.0 | .NET 6.0 | 1.8512 ns | 0.0082 ns | 0.0077 ns | 0.61 | - | - | - | NA | | ReadPriByCachedDelegate | .NET 7.0 | .NET 7.0 | 3.0252 ns | 0.0102 ns | 0.0090 ns | 1.00 | - | - | - | NA | | | | | | | | | | | | ReadPriByExpression | .NET 6.0 | .NET 6.0 | 47,972.7743 ns | 273.5695 ns | 255.8971 ns | 0.84 | 1.4038 | 0.6714 | 4551 B | 0.99 | | ReadPriByExpression | .NET 7.0 | .NET 7.0 | 57,030.6131 ns | 192.3719 ns | 170.5327 ns | 1.00 | 1.4648 | 1.0376 | 4583 B | 1.00 | | | | | | | | | | | | | | ReadPriByCachedExpression | .NET 6.0 | .NET 6.0 | 1.1444 ns | 0.0163 ns | 0.0136 ns | 0.62 | - | - | - | NA | | ReadPriByCachedExpression | .NET 7.0 | .NET 7.0 | 1.8552 ns | 0.0073 ns | 0.0068 ns | 1.00 | - | - | - | NA | 简单总结如下：\n通过表达式树访问属性，除直接访问属性外，其性能最佳，但是开销较大，且编写繁琐。 通过反射访问属性，在 .Net7 中优化显著，同时利用缓存也可以获得较好的性能。 通过委托访问属性，其性能和开销较为均衡，适合大多数性能优化使用。 ","permalink":"https://kiyanyang.github.io/posts/8c9c9dbd/","summary":"通过对 .Net6 和 .Net7 反射性能的简要测试，为性能优化提供依据。","title":".Net 反射性能测试"},{"content":"全新安装系统或更换系统平台都会涉及软件的配置。本文记录部分软件配置的导出与导入，为更换系统做好准备。\nGPG 用于 Git 签名。\n导出 GPG 公钥和私钥 首先，获取当前的密钥 ID。\nBash 1 2 3 4 5 6 7 $ gpg --list-secret-keys --keyid-format LONG /c/Users/Kiyan/.gnupg/pubring.kbx --------------------------------- sec rsa4096/5EA7CCF9AE45881 2021-12-02 [SC] E0F6D17529979CA92FA21385EA7CCF9BAE45881 uid [ultimate] Kiyan \u0026lt;Kiyan@outlook.com\u0026gt; ssb rsa4096/B8DC108324DD3BF 2021-12-02 [E] 之后，使用该密钥 ID 导出公钥和私钥，请妥善保管导出的密钥。\nBash 1 2 gpg --armor --output pub.gpg --export 5EA7CCF9AE45881 gpg --armor --output sec.gpg --export-secret-key 5EA7CCF9AE45881 导入 GPG 公钥和私钥并添加信任 导入上一步导出的密钥。\nBash 1 2 gpg --import ~/pub.gpg gpg --allow-secret-key-import --import ~/sec.gpg 使用 gpg --list-secret-keys --keyid-format LONG 查看密钥信息：\nBash 1 2 3 4 5 6 7 $ gpg --list-secret-keys --keyid-format LONG /c/Users/Kiyan/.gnupg/pubring.kbx --------------------------------- sec rsa4096/5EA7CCF9AE45881 2021-12-02 [SC] E0F6D17529979CA92FA21385EA7CCF9BAE45881 uid [ unknown] Kiyan \u0026lt;Kiyan@outlook.com\u0026gt; ssb rsa4096/B8DC108324DD3BF 2021-12-02 [E] 如果 uid 行出现 [ unknown] 说明信任级别未设置，需要将其设为导出时的信任级别 ultimate。\n添加信任，使用 gpg –-edit-key \u0026lt;your key id\u0026gt;，具体操作如下：\n打开 Git Bash，输入 gpg –-edit-key \u0026lt;your key id\u0026gt;。 选择密钥（键入数字，比如 1）。 输入 trust 来设置信任。 选择第 5 个选项（5 = I trust ultimately）。 输入 quit 退出。 再次使用 gpg --list-secret-keys --keyid-format LONG 查看密钥信息：\nBash 1 uid [ultimate] Kiyan \u0026lt;Kiyan@outlook.com\u0026gt; 信任级别已和导出时的级别一致。\nGit 导出 Git 用户配置 主要是用户级别的配置，Windows 下的地址为 C:\\Users\\\u0026lt;UserName\u0026gt;\\.gitconfig，将该文件备份。\n导入 Git 用户配置 将备份文件放回原位置。\n但是从旧版 Git 切换到新版本的 Git，可能会出现旧仓库无法使用的问题，同时 Git 报错 fatal: unsafe repository，该错误是 Git 添加 CVE-2022-24765 漏洞补丁所引起的。\n解决方法：\n将仓库地址添加到用户配置\nBash 1 2 git config --global --add safe.directory D:/repo1 git config --global --add safe.directory D:/repo2 或者直接在配置文件 .gitconfig 中编辑\nText 1 2 3 [safe] directory = D:/repo1 directory = D:/repo2 可以使用通配符 * 忽略所有仓库，比如\nBash 1 git config --global --add safe.directory \u0026#34;*\u0026#34; 或\nText 1 2 [safe] directory = * 使用云同步的软件配置 Microsoft Edge Firefox 浏览器 Visual Studio Code Visual Studio 参考 GitHub 的 GPG Key 配置与导出 Troubleshooting GnuPG – gpg: no ultimately trusted keys found git 报错 fatal: unsafe repository 解决方法 附录-软件 安装版 全新安装系统需要重新安装之前安装的软件，推荐使用 winget install --id \u0026lt;ID\u0026gt; -source winget，下表以安装先后排序：\n软件 Winget ID Microsoft Edge Microsoft.Edge Firefox 浏览器 Mozilla.Firefox 火绒安全软件 Bandizip Bandisoft.Bandizip Visual Studio Code Microsoft.VisualStudioCode Git Git.Git PowerShell Microsoft.Powershell PotPlayer Daum.PotPlayer Honeyview Bandisoft.Honeyview QQ Tencent.QQ 微信 Tencent.WeChat MicroSoft Office 使用 Office Tool Plus 安装 WPS Office Kingsoft.WPSOffice Snipaste 从微软商店安装 AirExplorer AirExplorer.AirExplorer winget 自动补全参见「winget 启用 tab 自动补全」。\n便携版 将便携版软件放在系统盘之外，全新安装系统后无需重新安装。\n软件 功能 Geek Uninstaller 卸载软件，导出软件列表 Dism++ 系统管理，RE Everything 搜索 Office Tool Plus 安装 MicroSoft Office noMeiryoUI 更换字体，Windows 11 22H2 不要替换「标题栏」 HEU KMS Activator 激活 Windows 附录-字体 思源宋体 Inconsolata HarmonyOS Sans SC ","permalink":"https://kiyanyang.github.io/posts/dd6adb6d/","summary":"全新安装系统或更换系统平台都会涉及软件的配置与安装。本文记录部分软件配置的导出与导入，同时附带软件列表。","title":"重装系统之软件配置与安装"},{"content":"由于 Hexo 较难在主题之外的地方自定义功能，而且构建速度较慢，因此将博客迁移至 Hugo。\n迁移 迁移的时候，除了参考官方文档之外，也参考了一些 Hugo 主题文档：\nDoIt 主题文档 LoveIt 主题文档 MemE 主题文档 入门以「DoIt 主题文档」为主，了解 Hugo 的基础使用和功能特性，同时参考其他两个主题文档，将基于 Hexo 的博客内容迁移至 Hugo。\n在完成内容迁移之后，可以阅读 Hugo 与 Hexo 的异同 这篇文章，深入了解其异同，详细阅读并依此进行博客修改后，就可以进入 Hugo 的世界了。\n以下补充一些博主迁移时遇到的问题及解决方案：\nGitInfo 使用 Git 时间作为文章的修改时间（lastmod）时，注意设置 enableGitInfo，而且仓库需完整，CI/CD 时尤其要注意这一点，例如 Cloudflare Pages 默认克隆最近一次提交，需要在构建命令前添加 git fetch --unshallow 命令，来补完仓库内容。\nTaxonomies 对于分类 Taxonomies，如果项（Term）包含“特殊”字符则读取 Git 时可能出现路径不匹配的情况，需要设置 git config --global core.quotepath false。\n建议“项”不要包含特殊标点，例如 .# 等，目前 Hugo 对特殊标点的处理还不完善，还有注意有些标点会进行转义，例如 （空格）转为 - 等，因此最好使用简短无特殊字符的内容作为项，而将名称写入 title，下面举例说明：\n对于 .Net Core 3.1 tag，在文章的 Front Matter 中使用 tag: [netcore31]；之后定义其元数据，元数据定义于 /content/\u0026lt;TAXONOMY\u0026gt;/\u0026lt;TERM\u0026gt;/_index.md，此例的位置就是 /content/tags/netcore31/_index.md，内容如下\nYAML 1 2 3 4 --- title: .Net Core 3.1 slug: dotnet-core-3.1 --- 配合配置文件中的 permalinks.tags: /tags/:slug/ 就可以实现，标签显示为 .Net，而其链接为 tags/dotnet-core-3.1 的效果。\n深入 对于博客的内容和样式深度的自定义就需要阅读官方文档了。\n附录 之前写过一篇文章关于 GitHub Actions 自动部署的，迁移至 Hugo 后修改记录在此。\nGitHub Actions YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 name: Deploy Blog Pages on: push: branches: - main paths-ignore: - .gitignore - .github/** - .vscode/** - archetypes/** jobs: build-and-deploy-hugo: runs-on: ubuntu-latest timeout-minutes: 5 defaults: run: shell: pwsh steps: # 部署到 Cloudflare Pages - name: Deploy to Cloudflare Pages run: | Invoke-WebRequest -Uri \u0026#39;${{ secrets.CF_HOOK }}\u0026#39; -Method Post continue-on-error: true - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Disable git.core.quotePath run: git config --global core.quotepath false - name: Build run: hugo # 部署到 GitHub Pages - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PAT }} external_repository: KiyanYang/KiyanYang.github.io publish_branch: main publish_dir: ./public Cloudflare Pages 设置构建命令为 git fetch --unshallow \u0026amp;\u0026amp; git config --global core.quotepath false \u0026amp;\u0026amp; hugo --environment=cloudflare-pages，因为 Hugo 依赖于 baseURL，因此增加 cloudflare-pages 配置，参考文档 Configure Hugo，我的配置目录结构如下：\n├── config │ ├── _default │ │ ├── config.yaml │ │ ├── languages.yaml │ │ └── params.yaml │ └── cloudflare-pages │ ├── config.yaml │ └── params.yaml ","permalink":"https://kiyanyang.github.io/posts/c859e42e/","summary":"记录博客从 Hexo 迁移至 Hugo 所需的参考文档，以及遇到的问题及解决方案。","title":"从 Hexo 迁移至 Hugo 小记"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\n使用 Hexo 过滤器（Filter）实现 Fluid 主题的代码折叠。\n过滤器简介 过滤器（Filter）细节参见「官方文档」。\n过滤器（Filter）用于修改特定文件，Hexo 将这些文件依序传给过滤器，而过滤器可以针对文件进行修改。注册过滤器的方式如下：\nJavaScript 1 2 3 4 5 6 7 hexo.extend.filter.register( type, function () { // do something... }, priority ); priority 是过滤器的优先级，priority 值越小，过滤器会越早执行，默认的 priority 是 10。\n思路 我们可以自定义一个过滤器，在文章完成渲染后增加折叠功能的代码。\n折叠功能借助 Bootstrap - Collapse 实现。此外，Fluid 主题已引入 Bootstrap，我们无需再次引入。\n实现 在 scripts/ 目录下新建文件 \u0026lt;fileName\u0026gt;.js，文件名自定，内容如下：\nJavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026#34;use strict\u0026#34;; // 获取唯一 ID function getUuid() { return Math.random().toString(36).substring(2, 8) + Date.now().toString(36); } hexo.extend.filter.register( \u0026#34;after_post_render\u0026#34;, (data) =\u0026gt; { const { line_number, lib } = hexo.theme.config.code.highlight; let reg; if (lib === \u0026#34;highlightjs\u0026#34;) { if (line_number) { reg = /(\u0026lt;figure class=\u0026#34;highlight.+?\u0026gt;)(.+?hljs (.*?)\u0026#34;.+?)(\u0026lt;\\/figure\u0026gt;)/gims; } else { reg = /(\u0026lt;div class=\u0026#34;code-wrapper.+?\u0026gt;)(.+?hljs (.*?)\u0026#34;.+?)(\u0026lt;\\/div\u0026gt;)/gims; } } else if (lib === \u0026#34;prismjs\u0026#34;) { reg = /(\u0026lt;div class=\u0026#34;code-wrapper.+?\u0026gt;)(.+?data-language=\u0026#34;(.*?)\u0026#34;.+?)(\u0026lt;\\/div\u0026gt;)/gims; } data.content = data.content.replace(reg, (match, begin, inner, lang, end, offset, string) =\u0026gt; { const collapseId = `collapse-${getUuid()}`; // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 设置折叠按钮图标，此处使用 GitHub 图标 const collapseBtn = `\u0026lt;i class=\u0026#34;iconfont icon-github-fill\u0026#34; type=\u0026#34;button\u0026#34; data-toggle=\u0026#34;collapse\u0026#34; data-target=\u0026#34;#${collapseId}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;`; const collapseDiv = `\u0026lt;div class=\u0026#34;collapse show\u0026#34; id=\u0026#34;${collapseId}\u0026#34;\u0026gt;${inner}\u0026lt;/div\u0026gt;`; const langSpan = `\u0026lt;span\u0026gt;${lang}\u0026lt;/span\u0026gt;`; return begin + collapseBtn + langSpan + collapseDiv + end; }); return data; }, 10000 // 应该在完成其他渲染后执行，因此将优先级设大一点 ); 此时的效果如图（使用 highlightjs）：\n增加相应的样式，进行美化：\nStylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 .markdown-body .highlight table, .markdown-body .code-wrapper pre { border-radius: 0 0 0.5rem 0.5rem; } .markdown-body .highlight, .markdown-body .code-wrapper { background-color: #e6ebf1; border-radius: 0.625rem; // 折叠图标 \u0026gt; i { color: #777777; margin-left: 10px; line-height: 2rem; transform: none; transition: color 0.2s ease-in-out, transform 0.2s ease-in-out; \u0026amp;.collapsed { transform: rotate(-90deg); } } // 代码语言 \u0026gt; span { color: #777777; margin-left: 10px; font-weight: bold; } } [data-user-color-scheme=\u0026#39;dark\u0026#39;] { .markdown-body .highlight, .markdown-body .code-wrapper { background-color: #696969; transition: background-color 0.2s ease-in-out; \u0026gt; i { color: #c4c6c9; } \u0026gt; span { color: #c4c6c9; transition: color 0.2s ease-in-out; } } } 效果如下：\n参考 过滤器（Filter） ","permalink":"https://kiyanyang.github.io/posts/c4dd4019/","summary":"使用 Hexo 过滤器（Filter）实现 Fluid 主题的代码折叠。","title":"使用 Hexo 过滤器实现 Fluid 主题的代码折叠"},{"content":"本文在 Windows11 平台使用 Visual Studio 2022 编译 VTK 9.1.0。\n前置条件 本文所需文件或工具：\n文件或工具 版本 网址 VTK 源码 9.1.0 https://vtk.org/download/ Visual Studio 2022 17.2+ https://visualstudio.microsoft.com/downloads/ CMake 3.23.1 https://cmake.org/download/ Qt 5.12 https://www.qt.io/download 注意：所需工具均为 64 位。\n编译前准备 在编译之前先准备好编译过程中所需的目录。目录结构如下：\nText 1 2 3 4 5 VTK ├─ VTK-9.1.0-src # 源码 ├─ VTK-9.1.0-bin # 编译生成的二进制数据 ├─ VTK-9.1.0-vs2022-x64-debug # 编译生成的库文件 └─ VTK-9.1.0-vs2022-x64-release # 编译生成的库文件 将下载的 VTK 源码放在 VTK-9.1.0-src 文件夹下。\nCMake 编译 打开 CMake (cmake-gui)，设置 VTK 源码和生成的二进制路径，点击 Configure。\n在配置对话框，选择 Visual Studio 17 2022，其他保持默认，点击 Finish。\n在配置完成后，会出现一些红色条目，表示需要进一步处理，这是正常现象，无需担心。\n在左上角搜索框搜索 BUILD_SHARED_LIBS，将其勾选。此项的作用是生成动态共享库 DLL。\n搜索 CMAKE_INSTALL_PREFIX，设置为 VTK 库要安装的位置，即 VTK 编译后的库文件位置。由于该项在设置后不可改变，因此为了可以同时生成 Debug 和 Release 两个版本，可以将该项设置为 VTK-9.1.0-vs2022-x64-debug 文件夹的路径。因为生成的库文件总是在 VTK-9.1.0-vs2022-x64-debug 文件夹，这样我们只需先生成 Release 模式下的库文件，然后将文件剪切到 VTK-9.1.0-vs2022-x64-release 文件夹，之后再生成 Debug 模式下的库文件即可。\n搜索 QT，将所有条目设为 Want，点击 Configure。\n在配置完成后，勾选 Grouped 和 Advanced。之后在 Ungrouped Entries 分组中选择 Qt5 的位置，路径为 Qt_DIR/5.12.0/msvc2017_64/lib/cmake/.*，如下图所示（一般情况下，CMake 会自动填入）。\n搜索 VTK_QT_VERSION，设置为 5，点击 Configure。\n在配置完成后，所有条目均为白色，说明没有错误。如果还是有红色，请返回检查，直到全白。点击 Generate。\n在生成完成后，所有条目均为白色，说明没有错误。点击 Open Project，打开 VS2022。\nVS2022 编译 选择「生成 -\u0026gt; 批生成」。\n在「Batch 生成」对话框，勾选 ALL_BUILD Release x64，点击生成，生成大约需要 40 分钟。\n等待生成完毕，之后再次进入「Batch 生成」对话框，取消勾选上述 ALL_BUILD Release x64，然后勾选 INSTALL Release x64，点击生成。\n此时，VTK-9.1.0-vs2022-x64-debug 文件夹内就是 VTK 9.1.0 Release 版本的库文件，将其剪切到 VTK-9.1.0-vs2022-x64-release 文件夹，就完成了 Release 版本的构建，最终 VTK-9.1.0-vs2022-x64-release 目录结构如下：\nText 1 2 3 4 5 VTK-9.1.0-vs2022-x64-release ├─ bin ├─ include ├─ lib └─ share 生成 Debug 模式下的库文件和上述过程相似。首先，取消勾选 INSTALL Release x64，然后勾选 ALL_BUILD Debug x64 和 INSTALL Debug x64，点击生成，就会在 VTK-9.1.0-vs2022-x64-debug 文件夹里生成库文件。\n在 Qt5 中使用 可以使用 QVTKOpenGLNativeWidget 部件，具体操作请查看「参考」。\n参考 VTK9.1.0 在 Windows10 + VS2019 + Qt 5.15.2 环境下编译安装以及 VTK 应用于 QT VTK8.2.0 在 Windows10 + VS2017 + Qt 5.12 环境下编译安装 ","permalink":"https://kiyanyang.github.io/posts/fdce5f9b/","summary":"本文在 Windows11 平台使用 Visual Studio 2022 编译 VTK 9.1.0。","title":"VTK9.1.0 + VS2022 + Qt5.12 编译"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\n本文章通过使用 GitHub Actions 自动将博客源文件部署到 GitHub Pages。此外还可以在 Actions 中主动调用 Cloudflare Pages 部署挂钩，来避免一些不必要的部署。\n前置条件 GitHub 账号 Cloudflare 账号 Hexo 博客源文件 创建 GitHub Pages 这里简要描述一下步骤：\n新建仓库 \u0026lt;user\u0026gt;.github.io，如果用户名包含大写字母，则必须改为小写字母。 选择仓库可见性为 public。 选择 Initialize this repository with a README（使用自述文件初始化此仓库）。 单击 Create repository（创建仓库）。 详细步骤可以查看 GitHub 文档“创建 GitHub Pages 站点”。\n创建博客源代码仓库 有两种方式：\n在 \u0026lt;user\u0026gt;.gitbub.io 仓库（即上面创建的 GitHub Pages 站点仓库），新建分支 source，然后将博客源文件上传至此分支。 新建仓库（此仓库的可见性可以设为 private），名称任意，比如 \u0026lt;user\u0026gt;.gitbub.io.source，然后将博客源文件上传至此分支。 我选择了第二种方式（因为源仓库可以设为 private），后续代码也依据第二种方式，不过可以很容易修改得到第一种方式的代码。\n编写 GitHub Actions 这里仅简单讲述一下相关的内容，更多关于 GitHub Actions 的内容请查看“官方文档”等。\n在 Hexo 源文件的根目录，新建 .github/workflows/\u0026lt;fileName\u0026gt;.yml 文件，文件名任意，比如 deploy-pages。\nYAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # 任务名称：任意 name: Deploy Blog Pages # 触发条件 on: # push，也就是推送到仓库时才执行任务 push: # 分支，这里选择 main，也就是只有推送到 main 分支时才执行任务【可选】 branches: - main # 忽略路径，也就是当只有这些路径发生变更时不会执行任务【可选】 paths-ignore: - \u0026#34;.github/**\u0026#34; - \u0026#34;scaffolds/**\u0026#34; - \u0026#34;source/_drafts/**\u0026#34; # 任务 jobs: # 任务名称，任意 build-and-deploy: # 服务器环境：最新版 Ubuntu runs-on: ubuntu-latest steps: # 拉取 - name: 📦 Checkout uses: actions/checkout@v2 # 生成静态文件 - name: 🔧 Install and Build run: | npm ci npm run build # 如果采用 yarn 进行包管理，则使用下面的代码 # yarn # yarn build # 部署到 GitHub Pages - name: 🚀 Deploy uses: JamesIves/github-pages-deploy-action@releases/v4 with: # GitHub 的 Personal access token token: ${{secrets.PAT}} # 更换为自己的 \u0026lt;user\u0026gt;/\u0026lt;user\u0026gt;.github.io repository-name: kiyanyang/kiyanyang.github.io # 要部署到的分支 branch: main # 上一步生成的静态文件的地址 folder: public 在“🚀 Deploy”步骤中，我们使用 Marketplace Actions 中的“Deploy to GitHub Pages”来部署到 GitHub Pages。其中需要 Personal access token，下面是获取步骤。\n在“Personal access tokens”页面点击右上角的 Generate new token 来生成一个新的 token，在生成页面的 Select scopes 中选择 workflow。注意要将生成的 token 保存好，因为只会在生成时显示一次，之后将无法查看。\n在博客源文件仓库的设置中打开 Secrets 页面。\n点击右上角 new repository secret 按钮来新建环境变量。\n变量的名称为 PAT（也可以为其他名称，但是要和“🚀 Deploy”步骤中的 token 的值内变量名称保持一致）。 变量的内容为上面生成的“Personal access tokens”。 至此使用 GitHub Actions 自动将博客源文件部署到 GitHub Pages 就完成了，可以将自己将源文件上传查看效果。\n部署 Cloudflare Pages 点击 Cloudflare Pages，转到 Pages（页面）\u0026gt; Create a project（创建项目）。\n选择 GitHub 上你的博客源文件仓库。 配置和部署 Project name（项目名称）：任意，此名称即为 Cloudflare Pages 的前缀，比如我的是 kiyanyang。 Production branch（生产分支）：一般为 main 或 master，也就是你博客源文件所处的分支。 Framework perset（框架预设）：选择 None。 Build command（构建命令）：npm run build 或 yarn build 按需选择一个。 Build output directory（构建输出目录）：public。 点击部署进行第一次部署。 部署完成后打开网站查看效果。\n使用部署挂钩 在 Cloudflare Pages 项目的“设置 \u0026gt; 构建与部署 \u0026gt; 自动 git 部署”可以看到，每当发生新的提交都会触发自动部署（无论博客源仓库的哪一分支），而 Cloudflare 每月只提供了 500 次免费部署，为了尽可能合理使用部署，我们可以关掉自动部署，开启部署挂钩，并使用 GitHub Actions 来请求部署。\n在“设置 \u0026gt; 构建与部署”\n自动 git 部署：点击“暂停部署”，来关闭自动部署。 部署挂钩：点击“添加部署挂钩”，挂钩名称任意。 在上面的 GitHub Actions 中新增步骤：\n注意将链接替换为自己的挂钩链接，或者和上面 token 一样使用环境变量。\nYAML 1 2 3 - name: 🚀 Deploy to Cloudflare Pages run: | curl -X POST \u0026#34;https://api.cloudflare.com/...\u0026#34; 这样的话，当 GitHub Pages 执行部署时，也会执行 Cloudflare Pages 的部署，不仅保证了站点内容的统一，也减少了一些不必要的构建。\n最终的 GitHub Actions 参考如下：\nYAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 name: Deploy Blog Pages # 触发条件 on: push: branches: - main paths-ignore: - \u0026#34;.github/**\u0026#34; - \u0026#34;scaffolds/**\u0026#34; - \u0026#34;source/_drafts/**\u0026#34; # 任务 jobs: build-and-deploy: # 服务器环境：最新版 Ubuntu runs-on: ubuntu-latest steps: # 部署到 Cloudflare Pages - name: 🚀 Deploy to Cloudflare Pages run: | curl -X POST \u0026#34;https://api.cloudflare.com/...\u0026#34; - name: 📦 Checkout uses: actions/checkout@v2 # 生成静态文件 - name: 🔧 Install and Build run: | yarn yarn build # 部署到 GitHub Pages - name: 🚀 Deploy uses: JamesIves/github-pages-deploy-action@releases/v4 with: token: ${{secrets.PAT}} repository-name: KiyanYang/KiyanYang.github.io branch: main folder: public ","permalink":"https://kiyanyang.github.io/posts/cdc6f5f3/","summary":"本文章通过使用 GitHub Actions 自动将博客源文件部署到 GitHub Pages，并在 Actions 中主动调用 Cloudflare Pages 部署挂钩，来避免一些不必要的部署。","title":"使用 GitHub Actions 自动部署 Hexo 博客"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\n此内容已过时。Hexo-Theme-Fluid 自 v1.8.14 起添加了此功能。\n由于 Hexo-Theme-Fluid 主题（v1.8.14 之前）的目录前没有光标，所以想自己增加一个光标，并添加切换动画。\n下面所描述的代码使用 stylus 格式，新建 source/css/toc.styl 文件，并在主题配置的 custom_css 添加文件路径 /css/toc（注意不带文件扩展名）。\n添加光标 Stylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 光标依赖位置 .toc-body \u0026gt; ol { position: relative; } // 光标 .toc-list-item { // 伪元素 \u0026amp;.is-active-li::before { // 伪元素内容，无需改动 content: \u0026#39;\u0026#39;; // 定位方式，无需改动 position: absolute; // 左侧偏移量 left: 0.25rem; // 光标高度 height: 0.25rem; // 光标外边距 margin: 0.625rem 0; // 光标宽度 width: 0.25rem; // 光标圆角 border-radius: 0.125rem; // 背景 background: black; } } 根据自己的需求，自行调整相应的数据。\n注意：要想让光标垂直居中的话，可以让其“高度 height ”加上“外边距 margin 中的上下边距”等于“目录标题项 .toc-list-item ”的高度（默认值为 1.5rem）。比如上面的设置：$0.25+0.625\\times2=1.5(rem)$ 。\n添加光标切换动画 我们可以设置 .toc-list-item::before 的激活状态和初始状态，然后添加其过渡动画 transition 来实现切换效果。\n首先将上面激活状态复制给初始状态：\nStylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .toc-list-item { // 初始状态 \u0026amp;::before { content: \u0026#39;\u0026#39;; position: absolute; left: 0.25rem; height: 0.25rem; margin: 0.625rem 0; width: 0.25rem; border-radius: 0.125rem; // 这里为了演示更换一下颜色 background: red; } // 激活状态 \u0026amp;.is-active-li::before { content: \u0026#39;\u0026#39;; position: absolute; left: 0.25rem; height: 0.25rem; margin: 0.625rem 0; width: 0.25rem; border-radius: 0.125rem; background: black; } } 使用 hexo server 打开本地服务查看效果如下：\n我们可以看到激活状态的光标（黑色）和初始状态的光标（红色）都显示出来了，我们不需要显示初始状态的光标，因此需要添加 visibility 属性，将初始状态的光标给隐藏掉，在初始状态中添加 visibility: hidden;。\n为了实现切换效果，那就需要将初始状态和激活状态的一些属性设为不同，比如我的是将 height 和 margin 设为不同的值。\n将具有不同值的属性加入到 transition，比如 transition: height 0.2s ease-in-out, margin 0.2s ease-in-out, visibility 0.2s ease-in-out; 。\ntransition 的具体描述可以参见“使用 CSS transitions”。\n可以把“激活状态”中与“初始状态”具有相同值的属性删除，至此光标的样式就全部完成了，最终结果如下：\nStylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 光标依赖位置 .toc-body \u0026gt; ol { position: relative; } // 光标 li.toc-list-item { // 初始状态 \u0026amp;::before { content: \u0026#39;\u0026#39;; position: absolute; left: 0.25rem; height: 0.25rem; margin: 0.625rem 0; width: 0.25rem; border-radius: 0.125rem; background: black; visibility: hidden; transition: height 0.2s ease-in-out, margin 0.2s ease-in-out, visibility 0.2s ease-in-out; } // 激活状态 \u0026amp;.is-active-li::before { height: 1rem; margin: 0.25rem 0; visibility: visible; } } 最终效果：\n夜间模式 可以设置夜间模式下的颜色：\nStylus 1 2 3 4 5 6 7 8 [data-user-color-scheme=\u0026#39;dark\u0026#39;] { .toc-list-item { \u0026amp;::before { background: orange; transition: background 0.2s ease-in-out; } } } 拓展 更多主题美化参见“Hexo-Fluid 博客美化和修改”。\n","permalink":"https://kiyanyang.github.io/posts/277e1260/","summary":"由于 Hexo-Theme-Fluid 主题（v1.8.14 之前）的目录前没有光标，所以想自己增加一个光标，并添加切换动画。","title":"Hexo-Fluid 在目录的标题前增加光标"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\n基于 Hexo-Theme-Fluid 博客主题的简单美化和修改，效果参见本博客自身。\n前置说明 适用版本：\nHexo v6.2.0 Fluid v1.9.0 下面所描述的样式代码使用 stylus 格式，请自行在 source/css 目录下新建 \u0026lt;fileName\u0026gt;.styl 文件，并在主题配置的 custom_css 添加文件路径（不带文件扩展名）。\n比如新建了 source/css/test.styl 文件，那就要在主题配置的 custom_css 添加 /css/test：\nYAML 1 2 custom_css: - /css/test 滚动条 Stylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ::-webkit-scrollbar { width: 10px; height: 6px; } ::-webkit-scrollbar-thumb { background-color: #a6a6a6; border-radius: 1rem; min-height: 60px; \u0026amp;:hover { background-color: #757575; } \u0026amp;:active { background-color: #424242; } } ::-webkit-scrollbar-corner { background-color: transparent; } [data-user-color-scheme=\u0026#39;dark\u0026#39;] { ::-webkit-scrollbar-thumb { background-color: #687582; \u0026amp;:hover { background-color: #9da8b3; } \u0026amp;:active { background-color: #c5d0db; } } } 代码块的复制按钮 Stylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .copy-btn { font-size: 1rem; color: darkslategrey; \u0026gt; i { font-size: 1rem !important; font-weight: bold; } } [data-user-color-scheme=\u0026#39;dark\u0026#39;] { .copy-btn { color: #c4c6c9; transition: color 0.2s ease-in-out; } } 圆角 包括对如下内容设置圆角：\n分类和归档页面内的文章列表 友链页面的卡片 菜单栏的按钮 页面背景板 返回顶部按钮 Stylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 分类页 .category { .row { border-radius: 1rem; } .category-item { border-radius: 1rem; } .category-post-list { border-radius: 1rem; } } // 归档页 .list-group { border-radius: 1rem; } // 分类和归档页共同 .list-group-item { border-radius: 1rem; } // 友链页 .links .card-body { border-radius: 1rem; } // 菜单栏 .navbar { .nav-item .nav-link { border-radius: 0.5rem; } .dropdown-menu { border-radius: 0.5rem; } .dropdown-item { border-radius: 0.25rem; } } // 页面背景板 #board { border-radius: 1rem; } // 返回顶部按钮 #scroll-top-button { border-radius: 0.5rem; } Waline 评论 适用版本：Waline v2\nStylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #waline { // 调整输入框左侧标签的大小，位置，文字 label { min-width: 1.75rem; font-size: 0.875rem; font-weight: bold; } // 调整输入框文字大小 input { font-size: 0.875rem; } // 将右下角的“计数，登录，提交”的伸缩属性设为自动，减少计数的换行 .wl-info { flex: auto; } .wl-card { // 调整 UA 标记的圆角和间距 .wl-meta\u0026gt;span { border-radius: 0.25rem; margin-right: 0.25rem; } // 调整博主名称标记的大小 .wl-badge { line-height: normal; padding: 0 0.25rem; } } } 网站运行时间 在主题配置中的 footer: content 添加：\nYAML 1 2 3 4 5 6 7 8 9 10 footer: # 前三行是 Fluid 原有的页脚内容，后面的是新增的内容 content: | \u0026lt;a href=\u0026#34;https://hexo.io\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;nofollow noopener\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Hexo\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-love\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/fluid-dev/hexo-theme-fluid\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;nofollow noopener\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Fluid\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div style=\u0026#34;font-size: 0.85rem\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;website-duration\u0026#34;\u0026gt;载入网站运行时间...\u0026lt;/span\u0026gt; \u0026lt;script src=\u0026#34;/js/duration.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; duration.js 包含的是功能代码，在博客目录下创建 source/js/duration.js，内容如下：\nJavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 !(function () { // 前面补零 function prefixInteger(num, n) { return (Array(n).join(0) + num).slice(-n); } // 计时起始时间，仿照格式自行修改 var start = Date.parse(\u0026#34;2021-07-10T16:03:05\u0026#34;); function update() { var now = Date.now() + 250; var interval = (now - start) / 1000; var days = Math.floor(interval / 60 / 60 / 24); var hours = Math.floor((interval / 60 / 60) % 24); var minutes = Math.floor((interval / 60) % 60); var seconds = Math.floor(interval % 60); hours = prefixInteger(hours, 2); minutes = prefixInteger(minutes, 2); seconds = prefixInteger(seconds, 2); document.getElementById( \u0026#34;website-duration\u0026#34; ).innerHTML = `本站已运行 ${days} 天 ${hours} 小时 ${minutes} 分 ${seconds} 秒`; } update(); setInterval(update, 250); })(); 已过时 代码块的首列固定 此内容已过时。Hexo-Theme-Fluid 自 v1.8.14 起添加了此功能。\nStylus 1 2 3 4 5 6 7 figure.highlight { td:first-child { position: sticky; left: 0; z-index: 1; } } 目录标题前的光标 此内容已过时，Hexo-Theme-Fluid 自 v1.8.14 起添加了此功能。\n关于目录标题前的光标的详细描述可以参见“Hexo-Fluid 在目录的标题前增加光标”。\nStylus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 光标依赖位置 .toc-body \u0026gt; ol { position: absolute; } // 当前标题前的光标 .toc-list-item { // 初始状态 \u0026amp;::before { content: \u0026#39;\u0026#39;; position: absolute; left: 0.25rem; height: 0.25rem; margin: 0.625rem 0; width: 0.25rem; border-radius: 0.125rem; background: black; visibility: hidden; transition: height 0.2s ease-in-out, margin 0.2s ease-in-out, visibility 0.2s ease-in-out; } // 激活状态 \u0026amp;.is-active-li::before { height: 1rem; margin: 0.25rem 0; visibility: visible; } } [data-user-color-scheme=\u0026#39;dark\u0026#39;] { .tocbot-active-link { color: orange; } .toc-list-item { \u0026amp;::before { background: orange; transition: background 0.2s ease-in-out; } } } 参考 Hexo Theme Fluid Fluid 页脚增加网站运行时长 ","permalink":"https://kiyanyang.github.io/posts/f92be1eb/","summary":"基于 Hexo-Theme-Fluid 博客主题的简单美化和修改，效果参见本博客自身。","title":"Hexo-Fluid 博客美化和修改"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\nVS Code 中关于 Hexo 的任务（Tasks）。\ntasks.json JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;清理、生成并预览\u0026#34;, \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34;, \u0026#34;dependsOn\u0026#34;: [\u0026#34;清理\u0026#34;, \u0026#34;生成\u0026#34;, \u0026#34;预览\u0026#34;], \u0026#34;problemMatcher\u0026#34;: [], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;清理\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo clean\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;生成\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo generate\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;预览\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo server\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;新建文章\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;new\u0026#34;, \u0026#34;post\u0026#34;, \u0026#34;${input:postName}\u0026#34;], \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;新建草稿\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;new\u0026#34;, \u0026#34;draft\u0026#34;, \u0026#34;${input:postName}\u0026#34;], \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] } ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;postName\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;文章名称\u0026#34; } ] } 参考 VS Code docs Integrate with External Tools via Tasks Variables Reference Hexo docs Commands ","permalink":"https://kiyanyang.github.io/posts/5a271947/","summary":"VS Code 中关于 Hexo 的任务（Tasks）。","title":"VS Code 中关于 Hexo 的任务（Tasks）"},{"content":"注意：本站已迁移至 Hugo。请访问本站「历史节点」获取有关 Hexo 的内容。\nVS Code 的任务可以运行脚本和启动进程，通过配置任务文件进行重复性工作，可以大大提高效率。\n本文章要实现目标是通过配置任务，可以使用 Ctrl+Shift+B（“运行生成任务”的快捷键）自动完成 Hexo 的清理、生成、开启本地预览，并且可以使用 VS Code 的“终端”菜单下的“运行命令”完成上述的单个命令。\n配置 Tasks 工作区的特定任务是从 Workspace 的 .vscode 文件夹中的 tasks.json 文件配置。\n新建 tasks.json 在 Hexo 工作区的 .vscode 文件夹下新建 tasks.json 文件。\n配置单个 Hexo 命令 以 hexo generate 命令为例，在 tasks.json 粘贴下面的代码。\nJSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { // 任务类型。 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, // 任务的用户界面中使用的标签；相当于变量名。 \u0026#34;label\u0026#34;: \u0026#34;local generate\u0026#34;, // 实际执行的命令。 \u0026#34;command\u0026#34;: \u0026#34;hexo generate\u0026#34;, // 定义如何在用户界面中处理任务输出，自行定义。 \u0026#34;presentation\u0026#34;: { // 命令面板。dedicated -\u0026gt; 如果任务已在命令面板中则重用此面板，否则新建面板。 \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, // 任务执行前是否清理命令面板。 \u0026#34;clear\u0026#34;: true }, // 问题匹配器，为空则不匹配任何问题。 \u0026#34;problemMatcher\u0026#34;: [] } ] } 代码中的参数根据注释和名称自行理解，想要查看更多的参数信息或关于 Tasks 的信息可以访问官方文档 。\n备注：上述任务中的 presentation 和 problemMatcher 是非必要的，但是实际使用时可以减少 VS Code 可能出现的询问次数。\n配置多个 Hexo 命令 我们还需要按照上述增加其他命令，添加后的代码如下：\nJSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;生成\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo generate\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, // ---------- // 新增代码 { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;清理\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo clean\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;预览\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo server\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] } // ---------- ] } 备注：tasks 内的任务书写无顺序之分。\n配置多个命令的顺序执行 代码如下：\nJSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ // ---------- // 新增代码。 { \u0026#34;label\u0026#34;: \u0026#34;清理、生成并预览\u0026#34;, // 执行顺序。sequence -\u0026gt; 顺序依次执行。 \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34;, // 执行本任务前要执行的任务。在此处依次写入其他任务的标签（label）。 \u0026#34;dependsOn\u0026#34;: [\u0026#34;清理\u0026#34;, \u0026#34;生成\u0026#34;, \u0026#34;预览\u0026#34;], \u0026#34;problemMatcher\u0026#34;: [], // 组。 \u0026#34;group\u0026#34;: { // 任务类型。 \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, // 是否为默认任务。 \u0026#34;isDefault\u0026#34;: true } }, // ---------- { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;清理\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo clean\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;生成\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo generate\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;预览\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo server\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] } ] } 其中本例内 group 的设置是为了将任务 local clear \u0026amp; server 设置为 VS Code “运行生成任务\u0026hellip;”功能的默认任务，这样我们才能通过快捷键 Ctrl+Shift+B 执行此任务。\n备注：新增的这个任务是一个自身不执行任何命令的任务。\n执行 Tasks 完成上面的设置后，我们在编辑了 Hexo 的文章或其他内容后使用 Ctrl+Shift+B 快捷键就可以自动完成 Hexo 的清理、生成、开启本地预览。\n如果想要执行上面配置的 3 个任务中的某一个，可以点击菜单栏“终端”下的“运行任务”来执行其中的任务。\n如果最近任务里没有自己定义的任务，可以点击最下方的“显示所有任务\u0026hellip;”来查看所有定义的任务。\n疑问与解答 为什么要创建 4 个任务，而不是将最后任务的依赖设为前两个，这样就只会有 3 个任务（比如如下代码），这难道不是更简洁吗？\nJSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;清理\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo clean\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;生成\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo generate\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [] }, // 最后一个任务执行前先执行其他两个 { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;预览\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hexo server\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;panel\u0026#34;: \u0026#34;dedicated\u0026#34;, \u0026#34;clear\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [], \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34;, \u0026#34;dependsOn\u0026#34;: [\u0026#34;清理\u0026#34;, \u0026#34;生成\u0026#34;], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } 解答：这样设置会导致无法使用单一的命令 hexo server，因为调用 local server 这个任务总会调用其他两个。当然如果你不需要有单独执行命令 hexo server 的任务，那你这样写也可以。\n只能通过 shell 类型的任务来完成本次的目标吗？ 答：当然不是，你也可以使用 npm 等类型的任务来完成目标。\n附录 你也可以参考上面的任务，自己添加 Hexo 的任务，比如一键部署等。\n关于我 Hexo 的 tasks.json 可以参见 VS Code 中关于 Hexo 的任务（Tasks）。\n参考 VS Code docs Integrate with External Tools via Tasks Hexo docs Commands ","permalink":"https://kiyanyang.github.io/posts/b66e483f/","summary":"本文通过配置 VS Code 任务，使用 \u003ccode\u003eCtrl+Shift+B\u003c/code\u003e（“运行生成任务”的快捷键）完成 Hexo 的清理、生成、开启本地预览，并且可以使用 VS Code 的“终端”菜单下的“运行命令”完成上述的单个命令。","title":"使用 VS Code 的任务（Tasks）便捷操作 Hexo"},{"content":"博客地址 博客 GitHub Pages Cloudflare Pages 感谢 博客系统 Hugo 博客主题 PaperMod 评论系统 giscus 图标 Font Awesome Simple Icons Feather 主题扩展 仙羡小站：滚动至评论按钮、文章版权说明 博客大事记 2022-08 启用 dotvast.cc 域名 2022-06 迁至 Hugo 建站，博客主题为 hugo-PaperMod 2021-12 启用 Cloudflare Pages 镜像站 2021-11 使用 GitHub Action 自动部署 2021-07 使用 Hexo 建站，博客主题为 hexo-theme-fluid ","permalink":"https://kiyanyang.github.io/about/","summary":"杨可的博客，分享我的想法和观点。 Kiyan\u0026rsquo;s Blog, Share my thoughts and opinions.","title":"关于"},{"content":" 在我们使用时会发现，只使用 Markdown 无法满足一些常用需求，比如文字颜色、位置、图片大小等。这时我们可以依托 Markdown 可与 HTML 混编的特性，直接在 Markdown 中使用 HTML，但是 HTML 内容丰富，对于普通用户而言只需使用其中一小部分内容，因此我在这里记录了一些常用的 HTML 语句来满足需求。\n颜色 效果:\n#123ABC 颜色\nMarkdown\nHTML 1 \u0026lt;span style=\u0026#34;color: #123ABC;\u0026#34;\u0026gt;#123ABC 颜色\u0026lt;/span\u0026gt; 大小 效果:\n0.85em 文字大小\nMarkdown\nHTML 1 \u0026lt;span style=\u0026#34;font-size:0.85em;\u0026#34;\u0026gt;0.85em 文字大小\u0026lt;/span\u0026gt; 位置 效果:\n居中 Markdown\nHTML 1 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;居中\u0026lt;/div\u0026gt; 位置可选值：left | center | right。\n折叠 效果:\n点击查看效果 左对齐 居中对齐 右对齐 A1 B1 C1 A2 B2 链接 Markdown\nMarkdown 1 2 3 4 5 6 7 8 9 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;点击查看效果\u0026lt;/summary\u0026gt; | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | ----------------------------------: | | _A1_ | `B1` | ~~C1~~ | | A2 | **B2** | [链接](https://KiyanYang.github.io) | \u0026lt;/details\u0026gt; summary 填写显示名称。\n注意\n在内部使用 Markdown 语句时要在前后留有空行，否则可能会当作普通文本处理，而且某些渲染器可能不支持在 html 内写 Markdown 文本，不支持时可以直接使用 html。\n图片 效果:\nMarkdown\nHTML 1 2 3 4 5 \u0026lt;img src=\u0026#34;/img/common/flower_200x300.webp\u0026#34; alt=\u0026#34;图片-1\u0026#34; width=\u0026#34;100\u0026#34; height=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;img src=\u0026#34;/img/common/flower_200x300.webp\u0026#34; alt=\u0026#34;图片-2\u0026#34; width=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;img src=\u0026#34;/img/common/flower_200x300.webp\u0026#34; alt=\u0026#34;图片-3\u0026#34; width=\u0026#34;20%\u0026#34; height=\u0026#34;20%\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; width 和 height 可全写、或只写 1 个、或全部不写，其值可为数字或百分比。\n表格 由于博客的主题样式，表格的边框、背景等元素可能与你使用下列代码时的效果不同。\n普通表格 效果:\n11 12 13 21 22 23 31 32 33 Markdown\nHTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;11\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;12\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;21\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;22\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;23\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;31\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;32\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;33\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 纵向合并单元格 效果:\n11 12 13 21 22 23 32 33 Markdown\nHTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;11\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;12\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;21\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;22\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;23\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;32\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;33\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 横向合并单元格 效果:\n11 12 13 21 23 31 32 33 Markdown\nHTML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;11\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;12\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;13\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;21\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;23\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;31\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;32\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;33\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; ","permalink":"https://kiyanyang.github.io/posts/89b5ce09/","summary":"只使用基础 Markdown 无法满足一些常用需求，比如文字颜色、图片大小等。这时我们可以依托 Markdown 可与 HTML 混编的特性，直接在 Markdown 中使用 HTML，本文记录了一些常用的 HTML 语句。","title":"Markdown 语法 拓展篇"},{"content":" Markdown 是一种轻量级标记语言，它使用易读易写的纯文本格式编写文档，可与 HTML 混编。因简洁、高效、易读、易写，Markdown 被大量使用。\n目前 CommonMark 被认为 Markdown 的现行规范，其规范对模棱两可的 Markdown 语法进行了极为必要的补充和标准化。本文内容若与该规范相悖，请以规范为准。\n文本元素 效果\n加粗\n斜体\n加粗斜体\nMarkdown\nMarkdown **加粗** *斜体* ***加粗斜体*** 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通段落不该用空格或制表符来缩进。\n提示：空行的定义是看起来是空的，便会被视为空行。比方说，若某一行只包含空格或制表符，那么该行便被视为空行。\n标题 Markdown 支持两种标题的语法，Setext 和 ATX 形式。\nSetext 形式是用底线的形式，利用 =（最高阶标题）和 -（第二阶标题），例如：\nMarkdown This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。\nATX 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\nMarkdown # 这是H1 ## 这是H2 ### 这是H3 #### 这是H4 ##### 这是H5 ###### 这是H6 你可以选择性地「闭合」ATX 样式的标题，即在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的 # 数量决定标题的阶数）：\nMarkdown # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 推荐使用 ATX 样式，且不要闭合标题。\n区块引用 Markdown 标记区块引用是使用 \u0026gt; 的引用方式。在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 \u0026gt; ：\n效果\nThis is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\nDonec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.\nMarkdown\nMarkdown \u0026gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, \u0026gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. \u0026gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u0026gt; \u0026gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse \u0026gt; id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套，只要根据层次加上不同数量的 \u0026gt; ：\n效果\nThis is the first level of quoting.\nThis is nested blockquote.\nBack to the first level.\nMarkdown\nMarkdown \u0026gt; This is the first level of quoting. \u0026gt; \u0026gt; \u0026gt; This is nested blockquote. \u0026gt; \u0026gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括列表、代码区块等：\n效果\n这是第一个列表项。 这是第二个列表项。 给出一个代码的例子：\nPython 1 return \u0026#34;Welcome to KiyanYang\u0026#39;s Blog\u0026#34; Markdown\nMarkdown \u0026gt; 1. 这是第一个列表项。 \u0026gt; 2. 这是第二个列表项。 \u0026gt; \u0026gt; 给出一个代码的例子： \u0026gt; \u0026gt; ```python \u0026gt; return \u0026#34;Welcome to KiyanYang\u0026#39;s Blog\u0026#34; \u0026gt; ``` 列表 Markdown 支持有序列表和无序列表。\n列表项目标记通常是放在最左边，但是也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n无序列表 无序列表使用星号、加号或减号作为列表标记：\n效果\nRed Green Blue Markdown\nMarkdown * Red * Green * Blue + Red + Green + Blue - Red - Green - Blue 注意\n星号 *、加号 + 或减号 - 仅起到标记这是无序列表的作用，即列表标记上使用不同的符号并不会影响输出的 HTML 结果。例如无序列表也可以这样写：\nMarkdown * Red + Green - Blue 有序列表 有序列表则使用数字接着一个英文句点：\n效果\nBird McHale Parish Markdown\nMarkdown 1. Bird 2. McHale 3. Parish 注意\n第一个数字标识有序列表的起始数字，后续数字仅起到标记这是有序列表的作用，即并不会影响输出的 HTML 结果。例如有序列表也可以这样写：\n苹果 香蕉 橘子 Markdown 3. 苹果 1. 香蕉 1. 橘子 或者：\n梨子 栗子 李子 Markdown 5. 梨子 4. 栗子 3. 李子 转义 如果想表达\n2004. 雅典奥运会\n2008. 北京奥运会\n2012. 伦敦奥运会\n但是却得到如下项目列表效果：\n2004. 雅典奥运会\n2005. 北京奥运会\n2006. 伦敦奥运会\n解决方案：在 . 前加上 \\ ，即：\nMarkdown 2004\\. 雅典奥运会 2008\\. 北京奥运会 2012\\. 伦敦奥运会 列表段落 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n效果\n金樽清酒斗十千，玉盘珍羞直万钱。 停杯投箸不能食，拔剑四顾心茫然。 欲渡黄河冰塞川，将登太行雪满山。 闲来垂钓碧溪上，忽复乘舟梦日边。 行路难，行路难，多歧路，今安在？ 长风破浪会有时，直挂云帆济沧海。\n莫听穿林打叶声，何妨吟啸且徐行。 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。\n料峭春风吹酒醒，微冷，山头斜照却相迎。 回首向来萧瑟处，归去，也无风雨也无晴。\nMarkdown:\nMarkdown - 金樽清酒斗十千，玉盘珍羞直万钱。 停杯投箸不能食，拔剑四顾心茫然。 欲渡黄河冰塞川，将登太行雪满山。 闲来垂钓碧溪上，忽复乘舟梦日边。 行路难，行路难，多歧路，今安在？ 长风破浪会有时，直挂云帆济沧海。 - 莫听穿林打叶声，何妨吟啸且徐行。 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。 回首向来萧瑟处，归去，也无风雨也无晴。 注意\n项目列表内如果需要换行，则和普通段落一样需要使用空行。\n列表嵌套 项目内可以使用其他引用元素，例如：\n效果\nA list item with a blockquote:\nThis is a blockquote inside a list item.\n各种效果都可以实现\n简单来说，项目列表内的区域等价于缩进之后的普通区域\nPython 1 2 def main(): pass Markdown\nMarkdown - A list item with a blockquote: \u0026gt; This is a blockquote \u0026gt; inside a list item. \u0026gt; \u0026gt; \u0026gt; 各种效果都可以实现 * 简单来说，项目列表内的区域等价于缩进之后的普通区域 ```python def main(): pass ``` 代码区块 代码区块的基础用法 要在 Markdown 中建立代码区块很简单，缩进 4 个空格或 1 个制表符即可，例如：\n效果\n这是一个普通段落：\n这是一个代码区块。 Markdown\nMarkdown 这是一个普通段落： 这是一个代码区块。 一个代码区块会一直持续到没有缩进的那一行（或文件结尾）。\n也可以使用 ` 或 ``` 来实现行内代码，这种方法可以标识代码语言，例如：\n效果\n这是行内代码 code，这是多行代码：\nPython 1 2 def main(): pass Markdown\nMarkdown 这是`行内代码 code`，这是多行代码： ```python def main(): pass ``` 代码区块的进阶用法 要在多行代码里嵌套多行代码，可使用更大的围栏包裹代码，如用 4 个反引号 `，例如写出上面内容的 Markdown 代码为\nMarkdown ```` 这是`行内代码 code`，这是多行代码： ```python def main(): pass ``` ```` 当然为了让此部分以代码块的形式显示，我使用了 5 个反引号来包裹此部分的代码。\n行内代码的开头或结尾包含反引号 ` 时，则开头和结尾必须包含空格。\n效果\n使用 ` 或 ``` 来实现行内代码\nMarkdown\nMarkdown 使用 `` ` `` 或 ` ``` ` 来实现行内代码 反引号的使用规则：\n对于区块代码，只需反引号做到前后闭合且反引号 ` 的数量和代码内反引号 ` 的数量不一致即可。例如可以使用 3 个反引号包围 4 个反引号：\n效果\nMarkdown 1 2 3 4 ```python def main(...): pass ``` Markdown\nMarkdown ``` ````python def main(...): pass ```` ``` 评价\n虽然可以这样使用，但是不建议在多行代码中使用这种用法，一般只在行内代码中这样使用。\n分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。例如：\nMarkdown *** * * * ***** - - - ----- 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n要建立一个行内式的链接，只要在方括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的标题，只要在网址后面，用双引号把标题包起来即可，例如：\n效果\n这是行内式的例子。\n这是行内式的加粗例子.\n这个链接没有标题文本段。\n查看关于页面获取更多信息。\nMarkdown\nMarkdown 这是行内式的[例子](https://example.com/ \u0026#34;标题1\u0026#34;)。 这是行内式的[**加粗例子**](https://example.com/ \u0026#34;标题2\u0026#34;). [这个链接](https://example.net/)没有`标题`文本段。 如果你是要链接到同样主机的资源，你可以使用相对路径：\nMarkdown 查看[关于](/about/)页面获取更多信息。 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\nMarkdown 这是参考式链接的[例子][id]。 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\nMarkdown [id]: https://example.com/ \u0026#34;可选标题\u0026#34; 链接内容定义的形式为：\n方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着标题内容，可以用单引号、双引号或括弧包着 下面这三种链接的定义都是相同：\nMarkdown [foo]: https://example.com/ \u0026#34;可选标题\u0026#34; [foo]: https://example.com/ \u0026#39;可选标题\u0026#39; [foo]: https://example.com/ (可选标题) 链接网址也可以用尖括号包起来：\nMarkdown [id]: \u0026lt;https://example.com\u0026gt; \u0026#34;可选标题\u0026#34; 你也可以把「标题」放到下一行，并增加一些缩进，网址太长时，这样会比较好看：\nMarkdown [id]: https://example.com/longish/path/to/resource/here \u0026#34;可选标题\u0026#34; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\nMarkdown [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \u0026ldquo;Google\u0026rdquo; 链接到 google.com，你可以简化成：\nMarkdown [Google][] 然后定义链接内容：\nMarkdown [Google]: https://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\nMarkdown Visit [Python documentation][] for more information. [Python documentation]: https://docs.python.org/ 链接的定义可以放在文件中的任何一个地方，一般直接放在链接出现段落的后面，也可以把它放在文件最后面，就像是注解一样。\n下面是两个参考式链接的例子：\n使用辨识链接的标记：\nMarkdown I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [Bing][3]. [1]: https://google.com/ \u0026#34;Google\u0026#34; [2]: https://search.yahoo.com/ \u0026#34;Yahoo Search\u0026#34; [3]: https://bing.com/ \u0026#34;Bing\u0026#34; 使用链接名称的方式：\nMarkdown I get 10 times more traffic from [Google][] than from [Yahoo][] or [Bing][]. [google]: https://google.com/ \u0026#34;Google\u0026#34; [yahoo]: https://search.yahoo.com/ \u0026#34;Yahoo Search\u0026#34; [bing]: https://bing.com/ \u0026#34;Bing\u0026#34; 图片 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n效果\nMarkdown\nMarkdown ![图片-1](https://blog.dotvast.cc/img/common/flower_200x300.webp) ![图片-2](https://blog.dotvast.cc/img/common/flower_200x300.webp \u0026#34;自定义标题\u0026#34;) 详细叙述如下：\n一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上可选的标题文字。 参考式的图片语法：\nMarkdown ![alt text][id] [id]: /path/to/image \u0026#34;可选标题\u0026#34; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 \u0026lt;img\u0026gt; 标签，参见拓展。\n公式 公式是非标准的 Markdown，但是目前绝大多数解析器均支持其解析。\n效果\n行内公式：$m\\times n$\n行内公式：$C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k}$\n块级公式： $$C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k}$$\n块级公式：\n$$ C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k} $$\nMarkdown\nMarkdown 行内公式：$m\\times n$ 行内公式：$C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k}$ 块级公式： $$C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k}$$ 块级公式： $$ C_{m\\times k}=A_{m\\times n}\\cdot B_{n\\times k} $$ 表格 表格也是非标准的 Markdown，但是目前绝大多数解析器均支持其解析。\n效果\n左对齐 居中对齐 右对齐 A1 B1 C1 A2 B2 C2 Markdown\nMarkdown | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | -----: | | A1 | B1 | C1 | | A2 | B2 | C2 | 表格只需要拥有形如 | 内容 | 或 |:--| 等结构即可，不必追求 | 对齐。例如下面的 Markdown 语句拥有和上面相同的效果：\nMarkdown | 左对齐|居中对齐 |右对齐 | |:-|:-:|-:| | A1| B1|C1 | |A2| B2| C2 | 此外表格内的内容也支持文字效果，图片等其他效果，可以参见拓展篇-折叠。\n反斜杠转义 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，任何 ASCII 标点字符均可转义，例如：\n效果:\n**加粗**\nMarkdown\nMarkdown \\*\\*加粗\\*\\* 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号 \u0026lt; \u0026gt; 包起来，例如：\n效果:\naddress@example.com\nhttps://blog.dotvast.cc\nMarkdown\nMarkdown \u0026lt;address@example.com\u0026gt; \u0026lt;https://blog.dotvast.cc\u0026gt; 拓展 本片为基础篇，也就是讲解 Markdown 自身的语法。此外有一些常用的功能，比如文字颜色、位置、图片大小等，这些只使用 Markdown 自身的语法无法实现。这时我们可以依托 Markdown 可与 HTML 混编的特性，直接在 Markdown 中使用 HTML，但是 HTML 内容丰富，对于普通用户而言只需使用其中一小部分内容，因此我在「Markdown 语法 拓展篇」中记录了一些常用的 HTML 语句来满足需求。\n参考 JOHN GRUBER - Markdown 创始人 CommonMark ","permalink":"https://kiyanyang.github.io/posts/78e09c9c/","summary":"Markdown 是一种轻量级标记语言，因简洁、高效、易读、易写，Markdown 被大量使用。本文介绍了 Markdown 的基本语法。","title":"Markdown 语法 基本篇"}]